import { writeFile } from 'node:fs/promises';
import path from 'node:path';

import { type Linter } from 'eslint';
// eslint-disable-next-line import-x/no-extraneous-dependencies
import * as prettier from 'prettier';

import { FILES_GLOB_IGNORES } from '../src/constants';
import { rules } from '../src/rules';

const FILE_NAME = 'generatedRules.ts';

const SAVE_PATH = './src/';

function mergeRules(
	configArr: ReadonlyArray<Readonly<Linter.Config>>,
): Linter.Config[] {
	const configsArrCopy: ReadonlyArray<Readonly<Linter.Config>> =
		structuredClone(configArr);

	return Object.values(
		configsArrCopy.reduce(
			(
				accumulator: Record<string, Linter.Config>,
				{
					files,
					ignores = FILES_GLOB_IGNORES,
					languageOptions,
					rules: configRules,
					settings,
				}: Linter.Config,
			) => {
				const configKey: string | undefined = files?.join('');

				if (configKey !== undefined && configKey.length > 0) {
					const configValue: Linter.Config = {
						files,
						ignores,
						languageOptions,
						rules: configRules,
						settings,
					};

					if (configKey in accumulator) {
						const existingConfigValue: Linter.Config = accumulator[configKey];

						configValue.ignores = [
							...new Set<string>([
								...(existingConfigValue.ignores ?? []),
								...ignores,
							]),
						];

						configValue.languageOptions = {
							...existingConfigValue.languageOptions,
							...languageOptions,
						};

						configValue.rules = {
							...existingConfigValue.rules,
							...configRules,
						};

						configValue.settings = {
							...existingConfigValue.settings,
							...settings,
						};
					}

					accumulator[configKey] = configValue;
				}

				return accumulator;
			},
			{},
		),
	);
}

const rulesValue: string = Object.entries(rules).reduce(
	(accumulator: string, [key, value]): string => {
		const withMergedRules: Linter.Config[] = mergeRules(
			value as ReadonlyArray<Readonly<Linter.Config>>,
		);

		const withSortedRules: Linter.Config[] = withMergedRules.map(
			({
				files,
				ignores,
				languageOptions = {},
				name,
				rules: configRules = {},
				settings = {},
			}: Linter.Config): Linter.Config => ({
				files,
				ignores,
				languageOptions:
					Object.values(languageOptions).length > 0
						? languageOptions
						: undefined,
				name,
				rules: Object.fromEntries(
					Object.entries(configRules).sort(([a], [b]) => a.localeCompare(b)),
				),
				settings: Object.values(settings).length > 0 ? settings : undefined,
			}),
		);

		return accumulator + `${key}:${JSON.stringify(withSortedRules)},`;
	},
	'',
);

const result = `
	// THIS IS A GENERATED FILE â€“ DO NOT EDIT!!!
	// Generated by '/scripts/generateConfigs.ts'\n
	import {type Rules} from './types';\n
	const rules:Rules={${rulesValue}};\n
	export default rules;
	`;

const prettierConfig = await prettier.resolveConfig('./.prettierrc.json');

const formattedResult: string = await prettier.format(result, {
	...prettierConfig,
	parser: 'typescript',
});

await writeFile(
	path.resolve(
		path.resolve(import.meta.dirname, '..'),
		path.join(SAVE_PATH, FILE_NAME),
	),
	formattedResult,
);
